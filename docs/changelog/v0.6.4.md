---
version: "0.6.4"
date: 2025-11-17
title: "IEEE 754 Compliance, Short-Circuit Operators, Range Operator & Developer Tooling"
description: "IEEE 754 special values, improved logical operators with short-circuit evaluation, range operator for sequences and iteration, plus comprehensive LSP and CLI tooling enhancements"
breaking: false
status: "Released"
highlights:
  - "IEEE 754 Compliance with Infinity and NaN"
  - "Short-Circuit Logical Operators with Truthy/Falsy Values"
  - "Range Operator for Sequences and Iteration"
  - "Default Values in Destructuring"
  - "Special Value Testing Functions (isnan, isinf, isfinite)"
  - "LSP Code Completion (151 items with fuzzy matching)"
  - "LSP Code Formatting and Signature Help"
  - "CLI Commands: format, lint, symbols"
  - "Enhanced REPL with Fuzzy Completion and Real-time Errors"
  - "LSP-Core Shared Library Architecture"
  - "Bug Fix: Type Patterns Now Correctly Bind Variables"
  - "Comprehensive LSP Documentation (14 files)"
---

## New Features

### Default Values in Destructuring

Achronyme now supports default values in destructuring patterns for both records and vectors. Defaults are lazily evaluated and only computed when the field or element is missing.

#### Record Destructuring with Defaults

```javascript
// Provide default values for missing fields
let user = { name: "Alice" }
let { name, age = 25 } = user

name  // "Alice"
age   // 25 (default used since field is missing)

// Default used only when field is absent
let user2 = { name: "Bob", age: 30 }
let { name: n, age: a = 25 } = user2

n  // "Bob"
a  // 30 (default ignored, field exists)

// Multiple defaults
let config = { host: "localhost" }
let { host, port = 8080, timeout = 30 } = config

host     // "localhost"
port     // 8080
timeout  // 30
```

#### Vector Destructuring with Defaults

```javascript
// Provide defaults for missing elements
let short = [1, 2]
let [a, b, c = 100] = short

a  // 1
b  // 2
c  // 100 (default used since element is missing)

// Defaults only computed when needed
let list = [10, 20, 30]
let [x, y, z = 999] = list

x  // 10
y  // 20
z  // 30 (existing value used, not default)

// Multiple defaults
let [first, second = 0, third = 0] = [42]

first   // 42
second  // 0
third   // 0
```

#### Lazy Evaluation

Defaults are only evaluated when actually needed:

```javascript
let counter = 0
let expensive = () => do {
    counter = counter + 1;
    counter * 10
}

let data = { x: 5 }
let { x, y = expensive() } = data

x        // 5
y        // 10 (expensive() called once)
counter  // 1

// When field exists, default not evaluated
let data2 = { x: 5, y: 20 }
let { x: x2, y: y2 = expensive() } = data2

x2       // 5
y2       // 20 (expensive() NOT called)
counter  // 1 (unchanged)
```

#### Using Outer Scope Variables

Defaults can reference variables from the outer scope:

```javascript
let defaultAge = 18
let defaultCity = "Unknown"

let user = { name: "Charlie" }
let { name, age = defaultAge, city = defaultCity } = user

name  // "Charlie"
age   // 18 (from outer scope)
city  // "Unknown" (from outer scope)
```

**Important**: Default expressions cannot reference other destructured variables from the same statement:

```javascript
// This works - using outer scope
let base = 10
let { x, y = base * 2 } = { x: 5 }

// This does NOT work - referencing sibling destructured variable
// let { x, y = x * 2 } = { x: 5 }  // ERROR: x not in scope yet
```

#### Mutable Destructuring with Defaults

Works with both `let` and `mut` bindings:

```javascript
mut { count = 0, total = 0 } = {}

count = count + 1  // 1
total = total + 10 // 10
```

#### Type Patterns with Defaults

Combine type pattern matching with default values for type-safe extraction:

```javascript
// Extract x only if it's a Number, use default if missing
let { x: Number = 10 } = { x: 42 }
// x is 42 (matches Number type)

let { x: Number = 10 } = {}
// x is 10 (field missing, default used)

let { x: Number = 10 } = { x: "Hello" }
// ERROR: Destructuring pattern does not match value
// (x exists but is String, not Number)

// String type pattern
let { name: String = "Anonymous" } = { name: "Alice" }
// name is "Alice"
```

**Important Semantic Meaning**: The syntax `{x: Number = 10}` means:
- "x **must** be a Number; if x is **missing**, use 10"
- It does **NOT** mean: "use x if it's a Number, otherwise use 10"

This is **validation-first**, not **fallback-first** behavior. The default is only used when the field is **missing**, not when the type doesn't match. If the field exists but has the wrong type, you get an error immediately. This intentional fail-fast behavior ensures type safety at runtime.

**Detailed Behavior**:

```javascript
// Case 1: Field missing - uses default
let {x: Number = 10} = {}
x  // 10 (default used)

// Case 2: Field exists and matches type - uses existing value
let {x: Number = 10} = {x: 42}
x  // 42 (field value used)

// Case 3: Field exists but WRONG type - ERROR (NOT fallback)
let {x: Number = 10} = {x: "bad"}
// ERROR: Destructuring pattern does not match value
// The default 10 is NOT used as a fallback!
```

This provides runtime type validation during destructuring.

### IEEE 754 Compliance

Achronyme now fully supports IEEE 754 special floating-point values for mathematical completeness.

#### Infinity Literals and Operations

```javascript
// Infinity literals
Infinity          // Positive infinity
-Infinity         // Negative infinity

// Operations producing Infinity
1 / 0             // Infinity
-1 / 0            // -Infinity
Infinity + 1      // Infinity
Infinity * 2      // Infinity

// Operations with Infinity
5 + Infinity      // Infinity
Infinity - Infinity  // NaN
Infinity / Infinity  // NaN
```

#### NaN (Not a Number)

```javascript
// NaN generation
0 / 0             // NaN
Infinity / Infinity  // NaN
Infinity - Infinity  // NaN

// Important behavior
NaN == NaN        // false (NaN is unique: not equal to itself)
NaN != NaN        // true
NaN == 0          // false
5 + NaN           // NaN (propagates through operations)

// Complex numbers preserve mathematical meaning
sqrt(-1)          // 0+1i (returns complex, not NaN)
// Real square root of negative returns NaN if needed
```

### Special Value Testing Functions

Three new built-in functions for testing special values:

```javascript
// isnan(value) - Check if value is NaN
isnan(0/0)        // true
isnan(NaN)        // true
isnan(5)          // false
isnan(Infinity)   // false

// isinf(value) - Check if value is Infinity or -Infinity
isinf(1/0)        // true
isinf(-1/0)       // true
isinf(Infinity)   // true
isinf(42)         // false
isinf(NaN)        // false

// isfinite(value) - Check if value is finite (not Infinity or NaN)
isfinite(42)      // true
isfinite(3.14)    // true
isfinite(1/0)     // false
isfinite(NaN)     // false
isfinite(Infinity) // false
```

### Short-Circuit Logical Operators

Logical operators now properly implement short-circuit evaluation and return values (not just booleans).

#### AND Operator (&&)

Returns the first falsy value, or the last value if all are truthy.

**Falsy values**: `false`, `null`, `0`, `NaN`, `""`

```javascript
// With booleans (traditional behavior)
true && true      // true
true && false     // false
false && true     // false

// With non-boolean values (short-circuit returns)
5 && 10           // 10 (both truthy, returns last)
0 && 10           // 0 (first is falsy, returns first)
"hello" && ""     // "" (second is falsy, returns second)
null && 42        // null (first is falsy, returns first)

// Common patterns
let user = {name: "Alice"}
user && user.name          // "Alice"
let empty = null
empty && empty.field       // null (no error)

// Prevent expensive function calls
let result = config && config.getValue()
// If config is falsy, getValue() is never called
```

#### OR Operator (||)

Returns the first truthy value, or the last value if all are falsy.

```javascript
// With booleans
true || false     // true
false || false    // false
false || true     // true

// With non-boolean values (short-circuit returns)
5 || 10           // 5 (first is truthy, returns first)
0 || 10           // 10 (first is falsy, returns second)
"" || "default"   // "default" (first is falsy, returns second)
null || 42        // 42 (first is falsy, returns second)

// Common patterns: default values
let name = userInput || "Anonymous"
// Use userInput if provided, otherwise use "Anonymous"

let config = customConfig || defaultConfig
// Fallback to default if custom is null/false/0

let port = process_port || 8080
// Use process_port if non-zero, otherwise 8080
```

### Range Operator

Create ranges of integers with exclusive (`..`) and inclusive (`..=`) operators.

#### Basic Ranges

```javascript
// Exclusive range (end not included)
1..5              // [1, 2, 3, 4]
0..10             // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
10..15            // [10, 11, 12, 13, 14]

// Inclusive range (end is included)
1..=5             // [1, 2, 3, 4, 5]
0..=10            // [0, 1, 2, ..., 10]
10..=15           // [10, 11, 12, 13, 14, 15]
```

#### With Variables

```javascript
let n = 5
1..n              // [1, 2, 3, 4]
1..=n             // [1, 2, 3, 4, 5]

let start = 0
let end = 10
start..end        // [0, 1, 2, ..., 9]
start..=end       // [0, 1, 2, ..., 10]
```

#### In Slicing

```javascript
let arr = [10, 20, 30, 40, 50]

// Exclusive slicing
arr[1..4]         // [20, 30, 40] (indices 1, 2, 3)
arr[0..2]         // [10, 20] (indices 0, 1)

// Inclusive slicing
arr[1..=4]        // [20, 30, 40, 50] (indices 1, 2, 3, 4)
arr[0..=2]        // [10, 20, 30] (indices 0, 1, 2)

// Using variables in slices
let start = 1
let end = 4
arr[start..end]   // [20, 30, 40]
```

#### In For-In Loops

```javascript
// Iterate with exclusive range
for(i in 0..5) {
    print(i)      // 0, 1, 2, 3, 4
}

// Iterate with inclusive range
for(i in 1..=5) {
    print(i)      // 1, 2, 3, 4, 5
}

// Process array with range
let arr = [10, 20, 30, 40, 50]
for(i in 0..arr.length) {
    print(arr[i])
}
```

#### Creating Sequences

```javascript
// Generate sequences
let numbers = 1..10
// [1, 2, 3, 4, 5, 6, 7, 8, 9]

let inclusive = 0..=100
// [0, 1, 2, ..., 100]

// Use in functional operations
let squared = map(x => x^2, 1..10)
// [1, 4, 9, 16, 25, 36, 49, 64, 81]

let filtered = filter(x => x % 2 == 0, 1..=10)
// [2, 4, 6, 8, 10]
```

## Developer Tooling Enhancements

### LSP Code Completion

Comprehensive code completion with 151 items, context-awareness, and fuzzy matching.

```javascript
// Type partial function names, get intelligent suggestions
sin   // Suggests: sin, sinh, sign, asin, asinh
ma    // Suggests: map, max, match, matrix, magnitude

// Context-aware completions
let    // Shows type keywords: Number, String, Boolean, Vector...
import // Shows available modules: stats, math, linalg...
```

**Features**:
- 110 built-in functions with full documentation
- 19 keywords (let, mut, if, match, etc.)
- 9 mathematical constants (PI, E, PHI, etc.)
- 14 type names (Number, String, Vector, Tensor, etc.)
- Rich snippets with parameter placeholders
- Fuzzy matching with Jaro-Winkler similarity

### LSP Code Formatting

Automatic code formatting with consistent style rules.

```bash
# Format a file
achronyme format src/main.ach

# Check formatting without modifying
achronyme format src/main.ach --check

# Show diff of proposed changes
achronyme format src/main.ach --diff
```

**Formatting Rules**:
- Operator spacing: `a + b`, `x == y`, `1..10`
- Comma normalization: `[1, 2, 3]` not `[1,2 ,3]`
- Brace formatting: `{ x: 1 }` with consistent spacing
- Type annotation spacing: `let x: Number = 10`
- Arrow operator alignment: `(a, b) => a + b`
- Control flow keyword spacing: `if (condition) { ... }`

### LSP Signature Help

Real-time function signature hints with 56+ functions documented.

```javascript
// As you type, signature help appears:
map(|
//  ↓
// map(fn: Function, array: Vector) -> Vector
//     ^^^^^^^^^^ active parameter highlighted

reduce(sum, 0|
//          ↓
// reduce(fn: Function, initial: Any, array: Vector) -> Any
//                      ^^^^^^^^^^^^ now this is active
```

**Features**:
- Parameter descriptions and types
- Active parameter highlighting
- Nested call support
- String-aware parsing (ignores commas in strings)

### CLI Format Command

Format Achronyme source files from the command line.

```bash
# Format file in place
achronyme format myfile.ach

# Check if file is properly formatted (exit code 1 if not)
achronyme format myfile.ach --check

# Show formatting diff
achronyme format myfile.ach --diff
```

### CLI Lint Command

Syntax checking and diagnostics for Achronyme files.

```bash
# Check file for errors
achronyme lint myfile.ach

# Output in JSON format for tooling integration
achronyme lint myfile.ach --json
```

**Example Output**:
```
src/main.ach: 2 issues found
  Line 15: Undefined variable 'userInput'
  Line 23: Type mismatch: expected Number, found String
```

### CLI Symbols Command

Extract and display document symbols (variables, types, functions).

```bash
# List all symbols in file
achronyme symbols myfile.ach

# Output in JSON format
achronyme symbols myfile.ach --json
```

**Example Output**:
```
Symbols in myfile.ach:
  let user: Record (line 3)
  mut counter: Number (line 5)
  type Point (line 8)
  let calculate: Function (line 12)
```

### Enhanced REPL with LSP Powers

The REPL now integrates LSP capabilities for a superior interactive experience.

#### Fuzzy Code Completion

```bash
ach> si<TAB>
sin    sinh   sign   size   slice  sigma
# Type any prefix or partial match

ach> mpa<TAB>
map  # Fuzzy matching corrects typos

ach> RED<TAB>
reduce  # Case-insensitive matching
```

**Features**:
- Jaro-Winkler fuzzy matching (score > 0.7)
- Prefix matches prioritized
- Top 15 suggestions shown
- Full documentation available for each suggestion

#### Inline Signature Help

```bash
ach> sin(PI / 2
     // sin(>x: Number<) -> Number
#         ^^^^^^^^^^^ active parameter highlighted

ach> map(x => x^2,
     // map(fn: Function, >array: Vector<) -> Vector
#                        ^^^^^^^^^^^^^^^ second parameter active
```

The REPL displays function signatures inline as you type, with the current parameter highlighted.

#### Real-time Error Detection

```bash
ach> let x = (5 + 3
# Input marked as incomplete (unclosed parenthesis)

ach> let x = if true 5
# Parse error: expected '{' after condition
```

**Validation Features**:
- Balanced delimiter checking (parentheses, brackets, braces)
- Real-time parse error detection
- Distinguishes incomplete input from invalid syntax
- Errors shown immediately, not after execution

### LSP-Core Shared Architecture

New `achronyme-lsp-core` crate provides shared completion and signature data.

```rust
// Single source of truth for completions
use achronyme_lsp_core::{get_all_completions, get_signature};

let completions = get_all_completions(); // 151 items
let sig = get_signature("map");          // Function signature
```

**Benefits**:
- No code duplication between LSP server and CLI
- Consistent completion items across all tools
- Shared function signature database
- ~1000 lines of code eliminated through consolidation

### Comprehensive LSP Documentation

14 new documentation files in `docs/lsp/`:

```
docs/lsp/
├── README.md                    # Overview and quick start
├── getting-started/
│   ├── installation.md          # Setup instructions
│   ├── editor-setup.md          # VSCode, Vim, Emacs config
│   └── configuration.md         # LSP server options
├── features/
│   ├── completion.md            # Code completion details
│   ├── formatting.md            # Formatting rules
│   ├── signature-help.md        # Function signatures
│   ├── hover.md                 # Hover information
│   ├── navigation.md            # Go to definition, find references
│   ├── diagnostics.md           # Error reporting
│   └── symbols.md               # Document outline
└── advanced/
    ├── architecture.md          # LSP implementation details
    ├── extending.md             # Adding new features
    └── troubleshooting.md       # Common issues
```

Total: 5,675 lines of comprehensive LSP documentation.

## Bug Fixes

### Type Patterns in Destructuring Now Correctly Bind Variables

Fixed a critical issue where type patterns in destructuring were not creating variable bindings.

**Previously broken**:
```javascript
let {x: String = "Hi"} = {}
x  // ERROR: Variable 'x' not found
// The variable x was never bound!
```

**Now fixed**:
```javascript
let {x: String = "Hi"} = {}
x  // "Hi" - variable x is properly bound to the default value

let {name: String = "Anonymous"} = {name: "Alice"}
name  // "Alice" - variable name is properly bound to the field value
```

This fix ensures that when you write `{fieldName: TypePattern = default}`, the variable `fieldName` is correctly bound in the current scope:
- If the field is missing, the variable is bound to the default value
- If the field exists and matches the type, the variable is bound to the field's value
- If the field exists but doesn't match the type, an error is raised (no binding occurs)

## Improvements

### Documentation Enhancements

- **Operators**: Clarified short-circuit evaluation and truthy/falsy values
- **Data Types**: Added comprehensive section on IEEE 754 special values
- **Examples**: Added range operator examples throughout documentation
- **Type Patterns**: Clarified validation-first semantics for type patterns with defaults

### Falsy Values Clarification

Achronyme uses consistent falsy value semantics across boolean contexts:

```javascript
// Falsy values: false, null, 0, NaN, ""
if(!false) { print("false is falsy") }    // Prints
if(!null) { print("null is falsy") }      // Prints
if(!0) { print("0 is falsy") }            // Prints
if(!NaN) { print("NaN is falsy") }        // Prints
if(!"") { print("empty string is falsy") } // Prints

// Truthy: everything else
if(1) { print("1 is truthy") }            // Prints
if("0") { print("'0' is truthy") }        // Prints (string "0", not number)
if([]) { print("[] is truthy") }          // Prints
if({}) { print("{} is truthy") }          // Prints
```

## Examples

### IEEE 754 in Practice

```javascript
// Handling division by zero safely
let safe_divide = (a, b) =>
    if(b == 0) {
        if(a == 0) NaN else if(a > 0) Infinity else -Infinity
    } else {
        a / b
    }

safe_divide(10, 2)   // 5
safe_divide(10, 0)   // Infinity
safe_divide(0, 0)    // NaN

// Testing for valid results
let validate_result = (value) =>
    if(isfinite(value)) {
        print("Valid: " + str(value))
    } else if(isinf(value)) {
        print("Infinite result")
    } else if(isnan(value)) {
        print("Invalid computation (NaN)")
    }
```

### Short-Circuit in Control Flow

```javascript
// Null coalescing pattern
let get_name = (user) => user && user.profile && user.profile.name

// Conditional execution
let user_logged_in = false
user_logged_in && (print("Welcome!"), update_ui())
// print() and update_ui() are never called

// Default values with multiple fallbacks
let config = custom_config || env_config || default_config
```

### Range in Data Processing

```javascript
// Generate test data
let test_scores = map(x => random() * 100, 1..50)  // 50 random scores

// Process specific range
let high_scores = filter(x => x >= 90, test_scores[0..20])

// Create lookup table
let multiplication_table = [
    for(i in 1..=10)
        for(j in 1..=10)
            i * j
]

// Generate coordinate grids
let grid_x = flatten([
    for(x in 1..=5)
        map(_ => x, 1..=5)
])

let grid_y = flatten([
    for(y in 1..=5)
        1..=5
])
```

## Technical Details

### IEEE 754 Implementation

- **Infinity**: Represented as IEEE 754 positive/negative infinity
- **NaN**: Represented as IEEE 754 NaN (any bit pattern with exponent all 1s and fraction non-zero)
- **Special operations**: Follow IEEE 754 standard behavior
- **Propagation**: NaN and Infinity propagate through calculations

### Operator Precedence Update

Range operators (`..` and `..=`) have been added to the precedence table between addition/subtraction and comparison operators.

```
Precedence (highest to lowest):
1. () [] .
2. ^
3. - !
4. * / %
5. + -
6. .. ..=          (NEW)
7. -> <>
8. == != < > <= >=
9. &&
10. ||
```

## Breaking Changes

None. All changes are backward compatible.

## Known Limitations

- Ranges only support integer steps (no custom step values like Python's `range(start, end, step)`)
- Range operations create full arrays in memory (not lazy sequences)
- IEEE 754 subnormal numbers are supported but not specially documented

## Migration Notes

### For Users of Previous Versions

1. **No code changes required** - All changes are backward compatible
2. **New capabilities available**:
   - Can now safely handle division by zero with Infinity
   - Use ranges for cleaner iteration: `for(i in 0..10)`
   - Leverage short-circuit operators for concise default handling

### For Library Creators

- Consider using `isnan()`, `isinf()`, `isfinite()` in validation functions
- Ranges provide convenient loop indices: `for(i in 0..array.length)`

## What's Next (v0.6.5)

- Async/await with Tokio runtime integration
- Array slicing with arbitrary step values
- Lazy range sequences (Iterator protocol improvement)
- `Array.from(range)` utilities
- Enhanced numeric tower documentation

---

## Summary of v0.6.4

### Language Features
- **IEEE 754 Compliance**: Full support for `Infinity` and `NaN`
- **Short-Circuit Operators**: `&&` and `||` return values with proper short-circuiting
- **Range Operator**: Convenient `..` and `..=` for sequences and iteration
- **Default Destructuring**: `let { x = 0 } = obj` and `let [a, b = 100] = list` with lazy evaluation
- **Type Pattern Validation**: `let { x: Number = 10 } = data` validates types at runtime (validation-first, not fallback-first)
- **Special Value Functions**: `isnan()`, `isinf()`, `isfinite()` for robust numeric code

### Developer Tooling
- **LSP Code Completion**: 151 items with fuzzy matching and context-awareness
- **LSP Code Formatting**: Automatic style enforcement with operator, comma, and brace normalization
- **LSP Signature Help**: 56+ function signatures with active parameter highlighting
- **CLI Format Command**: `achronyme format` with --check and --diff options
- **CLI Lint Command**: `achronyme lint` with JSON output support
- **CLI Symbols Command**: `achronyme symbols` for document outline
- **Enhanced REPL**: Fuzzy completion, inline signature hints, real-time error detection
- **LSP-Core Architecture**: Shared library eliminating ~1000 lines of code duplication
- **Comprehensive Documentation**: 14 LSP documentation files (5,675 lines total)

### Bug Fixes
- **Type Pattern Bindings**: Type patterns in destructuring now correctly bind variables

### Test Coverage
- 59 LSP tests (completion, formatting, signature help)
- 28 REPL helper tests (fuzzy matching, signature hints, error detection)
- 10 new destructuring tests for type pattern binding
- All 700+ existing tests continue to pass
