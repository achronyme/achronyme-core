// Test de Funciones de Grafos - Phase 4K
// Prueba todas las funciones de teoría de grafos implementadas en la VM

print("=== PRUEBAS DE TEORIA DE GRAFOS ===")
print("")

// ============================================================
// Test 1: Construcción de Red Básica
// ============================================================
print("--- Test 1: Construcción de Red Básica ---")

let edges1 = [
    A -> B,
    B -> C,
    C -> D,
    A -> C
]

let net1 = network(edges1)
print("Red creada:", net1)
print("Nodos:", nodes(net1))
print("Aristas:", edges(net1))
print("")

// ============================================================
// Test 2: Vecinos y Grado
// ============================================================
print("--- Test 2: Vecinos y Grado ---")

print("Vecinos de A:", neighbors(net1, "A"))
print("Vecinos de B:", neighbors(net1, "B"))
print("Vecinos de C:", neighbors(net1, "C"))
print("Grado de A:", degree(net1, "A"))
print("Grado de B:", degree(net1, "B"))
print("Grado de C:", degree(net1, "C"))
print("")

// ============================================================
// Test 3: Traversal (BFS y DFS)
// ============================================================
print("--- Test 3: Traversal (BFS y DFS) ---")

print("BFS desde A:", bfs(net1, "A"))
print("DFS desde A:", dfs(net1, "A"))

let path_result = bfs_path(net1, "A", "D")
print("Camino BFS de A a D:", path_result.path)
print("Encontrado:", path_result.found)
print("")

// ============================================================
// Test 4: Dijkstra (Camino más corto con pesos)
// ============================================================
print("--- Test 4: Dijkstra ---")

let weighted_edges = [
    A -> B: {weight: 5},
    B -> C: {weight: 3},
    A -> C: {weight: 8},
    C -> D: {weight: 2}
]

let weighted_net = network(weighted_edges)
let dijkstra_result = dijkstra(weighted_net, "A", "D")
print("Camino más corto de A a D:", dijkstra_result.path)
print("Distancia:", dijkstra_result.distance)
print("Encontrado:", dijkstra_result.found)
print("")

// ============================================================
// Test 5: Minimum Spanning Tree (Kruskal y Prim)
// ============================================================
print("--- Test 5: MST (Kruskal y Prim) ---")

let mst_edges = [
    A <> B: {weight: 4},
    A <> C: {weight: 3},
    B <> C: {weight: 2},
    B <> D: {weight: 5},
    C <> D: {weight: 6}
]

let mst_net = network(mst_edges)

let kruskal_result = kruskal(mst_net)
print("Kruskal MST:")
print("  Aristas:", kruskal_result.edges)
print("  Peso total:", kruskal_result.total_weight)

let prim_result = prim(mst_net, "A")
print("Prim MST (desde A):")
print("  Aristas:", prim_result.edges)
print("  Peso total:", prim_result.total_weight)
print("")

// ============================================================
// Test 6: Conectividad
// ============================================================
print("--- Test 6: Conectividad ---")

// Grafo conexo
let connected_edges = [
    A <> B,
    B <> C,
    C <> D
]
let connected_net = network(connected_edges)
print("Grafo conexo:")
print("  is_connected:", is_connected(connected_net))
print("  Componentes:", connected_components(connected_net))

// Grafo no conexo
let disconnected_edges = [
    A <> B,
    C <> D
]
let disconnected_net = network(disconnected_edges)
print("Grafo no conexo:")
print("  is_connected:", is_connected(disconnected_net))
print("  Componentes:", connected_components(disconnected_net))
print("")

// ============================================================
// Test 7: Detección de Ciclos
// ============================================================
print("--- Test 7: Detección de Ciclos ---")

// Grafo sin ciclos
let acyclic_edges = [
    A -> B,
    B -> C,
    A -> C
]
let acyclic_net = network(acyclic_edges)
print("Grafo sin ciclos:")
print("  has_cycle:", has_cycle(acyclic_net))

// Grafo con ciclos
let cyclic_edges = [
    A -> B,
    B -> C,
    C -> A
]
let cyclic_net = network(cyclic_edges)
print("Grafo con ciclos:")
print("  has_cycle:", has_cycle(cyclic_net))
print("")

// ============================================================
// Test 8: Ordenación Topológica
// ============================================================
print("--- Test 8: Ordenación Topológica ---")

let topo_edges = [
    A -> B,
    A -> C,
    B -> D,
    C -> D,
    B -> E,
    D -> E
]
let topo_net = network(topo_edges)
print("Orden topológico:", topological_sort(topo_net))
print("")

// ============================================================
// Test 9: Red con Propiedades de Nodos
// ============================================================
print("--- Test 9: Red con Propiedades de Nodos ---")

let node_props = {
    A: {color: "red", value: 10},
    B: {color: "blue", value: 20},
    C: {color: "green", value: 30}
}

let edges_with_props = [
    A -> B: {weight: 5},
    B -> C: {weight: 3}
]

let net_with_props = network(edges_with_props, node_props)
print("Red con propiedades de nodos:", net_with_props)
print("")

print("=== TODAS LAS PRUEBAS COMPLETADAS ===")
