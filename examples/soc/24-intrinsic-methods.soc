// ============================================================================
// Example 44: Intrinsic Methods and Fluid Interfaces
// ============================================================================// Demonstrates the power of intrinsic methods ("dot syntax") for built-in types.
// Achronyme supports both functional style (len(v)) and object-oriented style (v.len()).
// This enables "Method Chaining" for cleaner, more readable data processing pipelines.
//
// Features covered:
// - Vector methods (push, pop, map, filter, reduce, etc.)
// - String methods (trim, upper, split, etc.)
// - Number & Complex methods
// - Record introspection (keys, values)
// - Chaining methods for fluid data transformation
// ============================================================================

print("=== Part 1: Vector Manipulation ===")

// Vectors have mutable methods (like push/pop) and transformation methods
mut stack = [10, 20, 30]
print("Initial stack: " + str(stack))

stack.push(40)
stack.push(50)
print("After push: " + str(stack))

let top = stack.pop()
print("Popped: " + str(top))
print("Stack now: " + str(stack))

// Information methods
print("Length: " + str(stack.len()))
print("Is empty?: " + str(stack.is_empty()))
print("First: " + str(stack.first()))
print("Last: " + str(stack.last()))

// ============================================================================ 

print("\n=== Part 2: String Processing Pipeline ===")

// Cleaning up messy input data is much easier with chaining
let rawInput = "  User: Alice,  ID: 123,  Role: Admin  "
print("Raw input: '" + rawInput + "'")

// Traditional nested style (hard to read)
// let parts = split(replace(upper(trim(rawInput)), " "), ",")

// Fluid style (easy to read left-to-right)
let cleanParts = rawInput.trim().upper().replace(" ", "").split(",")

print("Clean parts: " + str(cleanParts))

// Check content
let isUser = cleanParts[0].starts_with("USER")
print("Is User record?: " + str(isUser))

// ============================================================================

print("\n=== Part 3: Functional Pipelines (Map/Filter/Reduce) ===")

let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// Calculate sum of squares of even numbers
// Style 1: Functional
// let result = reduce((acc, x) => acc + x, 0, map(x => x^2, filter(x => x % 2 == 0, numbers)))

// Style 2: Chained (Fluid)
let sumOfEvenSquares = numbers.filter(n => n % 2 == 0).map(n => n * n).reduce((acc, n) => acc + n, 0)

print("Numbers: " + str(numbers))print("Sum of squares of evens: " + str(sumOfEvenSquares))

// Check conditions
let hasBigNumber = numbers.any(n => n > 8)
let allPositive = numbers.all(n => n > 0)

print("Has number > 8?: " + str(hasBigNumber))
print("All positive?: " + str(allPositive))

// ============================================================================ 

print("\n=== Part 4: Numerical and Complex Methods ===")

// Numbers act like objects
let x = -15.75
print("Number: " + str(x))
print("  .abs()   -> " + str(x.abs()))
print("  .floor() -> " + str(x.floor()))
print("  .ceil()  -> " + str(x.ceil()))
print("  .str()   -> " + x.str()) // Convert to string explicitly

// Complex numbers
let z = 3 + 4i
print("Complex: " + str(z))
print("  .re() (Real)      -> " + str(z.re()))
print("  .im() (Imaginary) -> " + str(z.im()))
print("  .mag() (Magnitude)-> " + str(z.mag()))
print("  .conj() (Conjugate)-> " + str(z.conj()))

// ============================================================================ 

print("\n=== Part 5: Record Introspection ===")

// Records usually have fixed fields, but sometimes we need to treat them as maps
let config = {
    theme: "Dark",
    retries: 3,
    debug: true
}

print("Config object: " + str(config))

// Introspection methods
let keys = config.keys()
let values = config.values()

print("Keys: " + str(keys))
print("Values: " + str(values))

if(config.has("theme")) {
    print("Theme is set to: " + config.theme)
}

// Note: User-defined fields take precedence
let tricky = {
    keys: "This is a string, not a method",
    values: [10, 20]
}

print("Tricky object: " + str(tricky))
print("tricky.keys: " + tricky.keys) // Accesses the field, not the method
// To access the method on such an object, you would use the global keys(tricky) function

// ============================================================================ 

print("\n=== Part 6: First-Class Methods ===")

// Methods are values! You can assign them to variables.
let vec = [10, 20, 30]
let adder = vec.push  // 'adder' is now a function bound to 'vec'

print("Vector before: " + str(vec))
adder(40) // Calls vec.push(40)
adder(50)
print("Vector after calling bound method: " + str(vec))

// Passing methods as callbacks
let words = ["  hello ", " world "]
// We can map the .trim method of each string? 
// Not directly like .map(String.trim) because methods are bound to instances.
// But we can do:
let trimmed = words.map(w => w.trim())
print("Trimmed words: " + str(trimmed))

print("\nDone.")
