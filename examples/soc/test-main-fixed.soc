set_precision(2)

import { funcion1 } from "./modules/src/funcion1"
import { funcion2 } from "./modules/src/funcion2"
import { createCounter } from "./modules/src/contador"
import { makeAdder } from "./modules/src/makeAdder"
import { semaforo } from "./modules/src/semaforo"

let a = 10
let b = 20

let contadorPrueba = createCounter([1,2,3])
print("Estado actual del contador", contadorPrueba.value)
contadorPrueba.inc()
print("Estado despues de incrementar 1", contadorPrueba.value)
contadorPrueba.inc()
print("Estado despues de incrementar 1", contadorPrueba.value)

let add5 = makeAdder(5)
let add10 = makeAdder(10)

print(add5, add10)
print("Usando add5 con 20:", add5(20))
print("Usando add10 con 20:", add10(20))
print(funcion1(a,b))
print(funcion2(a,b))

print("Operaciones con complejos nativas asi es", e^(i*pi) + 1)

print("Estado inicial del semaforo", semaforo.luz)
print("Estado siguiente del semaforo", semaforo.next())
print("Estado siguiente del semaforo", semaforo.next())
print("Estado siguiente del semaforo", semaforo.next())

print("Intentando llamar a una IIFE para ver si la VM soporta esta caracteristica")

(() => do {
    print("IIFE llamada correctamente")
})()

print("IIFE que suma dos numeros:", ((x: Number, y: Number) => do {
    x + y
})(15, 25))

print("IIFE con valores opcionales y con tipos inferidos, ademÃ¡s de valores por defecto:", ((x, y: Number, z = 20) => do {
    if (z != null) {
        x + y + z
    } else {
        x + y
    }
})(10, 20))

let defecto = (x: Number, y: Number = 100, z: Number = 200) => do {
    x + y + z
}

let defectoSinTipo = (x, y = 100, z = 200) => do {
    x + y + z
}

print("Llamada a funcion con valores por defecto sin tipos:", defectoSinTipo(50))
print("Llamada a funcion con valores por defecto:", defecto(50))
